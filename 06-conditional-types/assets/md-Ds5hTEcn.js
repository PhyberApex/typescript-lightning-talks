import{_ as c,a as u}from"./Monaco.vue_vue_type_style_index_0_lang-Dztl_ZHK.js";import{I as m,_}from"./slidev/default--rSJtUSJ.js";import{o as d,c as f,k as o,e,l as n,ap as l,m as g,q as B,s as y,I as s}from"./modules/vue-CxoEfOET.js";import{u as k,f as C}from"./slidev/context-ZDP9l9q4.js";import"./index-BSIE-Pnq.js";import"./monaco/bundled-types-D1eOyKhu.js";import"./modules/file-saver-igGfcqei.js";import"./modules/shiki-D9MVKcn5.js";const b={__name:"slides.md__slidev_5",setup(I){const{$slidev:E,$nav:Q,$clicksContext:r,$clicks:x,$page:H,$renderContext:v,$frontmatter:a}=k();return r.setup(),(w,t)=>{const A=_,i=c,p=u;return d(),f(m,B(y(s(C)(s(a),4))),{default:o(()=>[t[1]||(t[1]=e("h1",null,"Advanced Usage: Inferring Within Conditional Types",-1)),n(A,null,{default:o(()=>t[0]||(t[0]=[e("ul",null,[e("li",null,[l("Use "),e("code",null,"infer"),l(" keyword to infer types within a conditional type")]),e("li",null,"Allows for extracting types from complex structures"),e("li",null,"Useful for creating utility types"),e("li",null,"Can infer return types, parameter types, and more"),e("li",null,"Enables powerful type transformations")],-1)])),_:1}),n(p,null,{default:o(()=>[n(i,g({"code-lz":"C4TwDgpgBAShwFcBOA7AKuCAeNA+KAvFGlBAB7AQoAmAzlABQB0LAhkgOa0BcUrKIANoBdAJSF8ASxQAzCElhQA/It78QAbgBQWgPS6oAVVqsOELTIQoAxsEkB7FFA5II8BilYBbCL1rAkaQ5RPwCgqABvLSgYqFdEVCgAAwAJCAAbdPsAGigAEgjPHwBfAEIk7WKdUEgoAHFXeDgEpyJm5HRMLBqIexlnRuBcDSh9YkwoSXp/QJQOHWtHfygUBC8AI3kAQSQkVhBCKEEARlyAJlyAZlyAFlyAVmFtHqgdvZAAUXSIHxRgHHwRBI5EoNHoDGkcgUhlEImURigvBQEAAbvJnhMAHJrTZIN77L4/KjAQ74z7fX7/Hp9FY47a7fbDUYGDC1Ka0jbyHRAA==",lang:"ts"},{}),null,16)]),_:1})]),_:1},16)}}};export{b as default};
